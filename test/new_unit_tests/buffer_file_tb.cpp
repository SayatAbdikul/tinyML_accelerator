#include "Vbuffer_file.h" // Generated by Verilator
#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <vector>
#include <verilated.h>

vluint64_t main_time = 0;
double sc_time_stamp() { return main_time; }

int main(int argc, char **argv) {
  Verilated::commandArgs(argc, argv);

  // Instantiate module with test parameters
  const uint32_t BUFFER_WIDTH = 1024; // Reduced for simulation
  const uint32_t TILE_WIDTH = 256;
  const uint32_t BUFFER_COUNT = 2;
  const uint32_t TILE_COUNT = BUFFER_WIDTH / TILE_WIDTH;
  const uint32_t WORDS_PER_TILE = TILE_WIDTH / 32;
  const uint32_t TILE_ELEMS = 32; // Number of bytes per tile

  Vbuffer_file *dut = new Vbuffer_file;

  // Initialize signals
  dut->clk = 0;
  dut->reset_n = 0;
  dut->write_enable = 0;
  dut->read_enable = 0;
  dut->write_buffer = 0;
  dut->read_buffer = 0;
  dut->reset_indices_enable = 0;
  dut->reset_indices_buffer = 0;

  // Initialize wide write_data signal to 0
  for (int i = 0; i < WORDS_PER_TILE; i++) {
    dut->write_data[i] = 0;
  }

  // Reset sequence (5 clock cycles)
  for (int i = 0; i < 10; i++) {
    dut->clk = !dut->clk;
    dut->eval();
    main_time++;
  }
  dut->reset_n = 1;

  // Test patterns as 4 uint64_t values
  const std::vector<std::vector<uint64_t>> test_patterns = {
      {0xAAAAAAAAAAAAAAAA, 0xBBBBBBBBBBBBBBBB, 0xCCCCCCCCCCCCCCCC,
       0xDDDDDDDDDDDDDDDD},
      {0x1111111111111111, 0x2222222222222222, 0x3333333333333333,
       0x4444444444444444},
      {0x5555555555555555, 0x6666666666666666, 0x7777777777777777,
       0x8888888888888888},
      {0x9999999999999999, 0xAAAAAAAAAAAAAAAA, 0xBBBBBBBBBBBBBBBB,
       0xCCCCCCCCCCCCCCCC}};

  // Helper function to set 256-bit write_data from 4 uint64_t values
  auto set_write_data = [&](const std::vector<uint64_t> &pattern) {
    for (int i = 0; i < 4; i++) {
      // Set lower 32 bits and upper 32 bits into the 8x32bit array
      dut->write_data[i * 2] = static_cast<uint32_t>(pattern[i] & 0xFFFFFFFF);
      dut->write_data[i * 2 + 1] =
          static_cast<uint32_t>((pattern[i] >> 32) & 0xFFFFFFFF);
    }
  };

  // Updated: Read data from unpacked array (32 bytes, each 8 bits)
  // The previous testbench assumed packed read_data, now it's an unpacked array
  // [32].
  auto read_data_to_hex = [&]() -> std::string {
    std::ostringstream oss;
    oss << std::hex << std::setfill('0');
    // Combine bytes to form 4 64-bit words for comparison (to match
    // pattern_to_hex format)
    for (int word64 = 0; word64 < 4; word64++) {
      uint64_t val64 = 0;
      for (int byte = 0; byte < 8; byte++) {
        int byte_index = word64 * 8 + byte;
        // Little endian construction
        val64 |=
            (static_cast<uint64_t>(dut->read_data[byte_index]) << (byte * 8));
      }
      oss << std::setw(16) << val64;
    }
    return oss.str();
  };

  // Helper to get expected hex string
  auto pattern_to_hex =
      [](const std::vector<uint64_t> &pattern) -> std::string {
    std::ostringstream oss;
    oss << std::hex << std::setfill('0');
    for (const auto &val : pattern) {
      // Print each 64-bit value as 16 hex characters
      oss << std::setw(16) << val;
    }
    return oss.str();
  };

  // Write test patterns to buffer 0
  std::cout << "\n=== Writing to Buffer 0 ===" << std::endl;
  dut->write_enable = 1;
  dut->write_buffer = 0;

  for (int tile = 0; tile < TILE_COUNT; tile++) {
    const int pattern_idx = tile % test_patterns.size();
    set_write_data(test_patterns[pattern_idx]);

    // Clock strobe
    dut->clk = 0;
    dut->eval();
    main_time++;

    dut->clk = 1;
    dut->eval();
    main_time++;

    std::cout << "Wrote tile " << tile << ": 0x"
              << pattern_to_hex(test_patterns[pattern_idx]) << std::endl;
  }

  // writing_done is registered: it asserts on the cycle AFTER the last tile.
  // In Verilator, we sample it on the neg-edge following the last write's
  // posedge.
  dut->write_enable = 0;
  dut->clk = 0;
  dut->eval();
  main_time++;
  // Now the non-blocking writing_done <= 1 from last posedge should be visible
  if (dut->writing_done != 1) {
    // Try one more full cycle in case of pipeline delay
    dut->clk = 1;
    dut->eval();
    main_time++;
    dut->clk = 0;
    dut->eval();
    main_time++;
    if (dut->writing_done != 1) {
      std::cerr << "Error: writing_done not asserted!" << std::endl;
      exit(EXIT_FAILURE);
    }
  }
  std::cout << "writing_done asserted" << std::endl;

  // Write different patterns to buffer 1
  std::cout << "\n=== Writing to Buffer 1 ===" << std::endl;
  dut->write_enable = 1;
  dut->write_buffer = 1;

  for (int tile = 0; tile < TILE_COUNT; tile++) {
    const int pattern_idx = (TILE_COUNT - 1 - tile) % test_patterns.size();
    set_write_data(test_patterns[pattern_idx]);

    // Clock strobe
    dut->clk = 0;
    dut->eval();
    main_time++;

    dut->clk = 1;
    dut->eval();
    main_time++;

    std::cout << "Wrote tile " << tile << ": 0x"
              << pattern_to_hex(test_patterns[pattern_idx]) << std::endl;
  }
  dut->write_enable = 0;

  // Read from buffer 0
  std::cout << "\n=== Reading from Buffer 0 ===" << std::endl;
  dut->read_enable = 1;
  dut->read_buffer = 0;

  for (int tile = 0; tile < TILE_COUNT; tile++) {
    // Clock strobe (read happens on rising edge)
    dut->clk = 0;
    dut->eval();
    main_time++;

    dut->clk = 1;
    dut->eval();
    main_time++;

    const int pattern_idx = tile % test_patterns.size();
    const std::string read_hex = read_data_to_hex();
    const std::string expected_hex = pattern_to_hex(test_patterns[pattern_idx]);

    std::cout << "Read tile " << tile << ": 0x" << read_hex << std::endl;
    std::cout << "Expected   : 0x" << expected_hex << std::endl;

    // Verify data
    if (read_hex != expected_hex) {
      std::cerr << "Mismatch! Expected: 0x" << expected_hex << " Got: 0x"
                << read_hex << std::endl;
      exit(EXIT_FAILURE);
    }
  }

  // reading_done is registered, so check one cycle after the last read
  dut->read_enable = 0;
  dut->clk = 0;
  dut->eval();
  main_time++;
  // Now visible at neg-edge? Wait, registered output is visible after posedge?
  // Actually, I logic for write was:
  // dut->clk = 0; dut->eval(); // neg-edge, check non-blocking assignment from
  // PREVIOUS posedge? No, non-blocking assignment outcome is only visible AFTER
  // the delta cycle of posedge. But Verilator eval() does all. The working
  // pattern for write was: dut->write_enable = 0; dut->clk = 0; dut->eval(); if
  // (dut->writing_done != 1) { try one more cycle }

  // Let's copy the EXACT working pattern from write check:
  if (dut->reading_done != 1) {
    dut->clk = 1;
    dut->eval();
    main_time++;
    dut->clk = 0;
    dut->eval();
    main_time++;
    if (dut->reading_done != 1) {
      std::cerr << "Error: reading_done not asserted!" << std::endl;
      exit(EXIT_FAILURE);
    }
  }
  std::cout << "reading_done asserted" << std::endl;

  // Read from buffer 1
  std::cout << "\n=== Reading from Buffer 1 ===" << std::endl;
  dut->read_enable = 1;
  dut->read_buffer = 1;

  for (int tile = 0; tile < TILE_COUNT; tile++) {
    // Clock strobe
    dut->clk = 0;
    dut->eval();
    main_time++;

    dut->clk = 1;
    dut->eval();
    main_time++;

    const int pattern_idx = (TILE_COUNT - 1 - tile) % test_patterns.size();
    const std::string read_hex = read_data_to_hex();
    const std::string expected_hex = pattern_to_hex(test_patterns[pattern_idx]);

    std::cout << "Read tile " << tile << ": 0x" << read_hex << std::endl;
    std::cout << "Expected   : 0x" << expected_hex << std::endl;

    // Verify data
    if (read_hex != expected_hex) {
      std::cerr << "Mismatch! Expected: 0x" << expected_hex << " Got: 0x"
                << read_hex << std::endl;
      exit(EXIT_FAILURE);
    }
  }
  dut->read_enable = 0;

  // Test reset functionality
  std::cout << "\n=== Testing Reset ===" << std::endl;
  dut->reset_n = 0;
  dut->clk = 0;
  dut->eval();
  main_time++;

  dut->clk = 1;
  dut->eval();
  main_time++;

  // Should reset indices to 0. Since block RAM is not cleared on reset,
  // the data output should be the first tile of the current read_buffer.
  // We need to set read_buffer to 0 to check the first written pattern.
  dut->read_buffer = 0;
  dut->read_enable = 1;
  dut->clk = 0;
  dut->eval();
  main_time++;
  dut->clk = 1;
  dut->eval();
  main_time++;

  const std::string reset_read_hex = read_data_to_hex();
  // Pattern 0 was written to Buffer 0 first
  const std::string expected_reset_hex = pattern_to_hex(test_patterns[0]);

  std::cout << "Read after reset: 0x" << reset_read_hex << std::endl;
  if (reset_read_hex != expected_reset_hex) {
    std::cerr
        << "Reset failed! Indices not reset to 0. Expected tile 0 data: 0x"
        << expected_reset_hex << " Got: 0x" << reset_read_hex << std::endl;
    exit(EXIT_FAILURE);
  }
  std::cout << "Reset successful (indices reset to 0)" << std::endl;

  // Cleanup
  dut->final();
  delete dut;

  std::cout << "\nAll tests passed successfully!" << std::endl;
  return EXIT_SUCCESS;
}