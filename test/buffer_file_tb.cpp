#include <verilated.h>
#include "Vbuffer_file.h"  // Generated by Verilator
#include <iostream>
#include <vector>
#include <cstdlib>
#include <iomanip>
#include <sstream>

vluint64_t main_time = 0;
double sc_time_stamp() { return main_time; }

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    
    // Instantiate module with test parameters
    const uint32_t BUFFER_WIDTH = 1024;   // Reduced for simulation
    const uint32_t TILE_WIDTH = 256;
    const uint32_t BUFFER_COUNT = 2;
    const uint32_t TILE_COUNT = BUFFER_WIDTH / TILE_WIDTH;
    const uint32_t WORDS_PER_TILE = TILE_WIDTH / 32;
    const uint32_t TILE_SIZE = 32; // Number of bytes per tile
    
    Vbuffer_file* dut = new Vbuffer_file;

    // Initialize signals
    dut->clk = 0;
    dut->reset_n = 0;
    dut->write_enable = 0;
    dut->read_enable = 0;
    dut->write_buffer = 0;
    dut->read_buffer = 0;
    
    // Initialize wide signals to 0
    for (int i = 0; i < WORDS_PER_TILE; i++) {
        dut->write_data[i] = 0;
    }

    // Reset sequence (5 clock cycles)
    for(int i = 0; i < 10; i++) {
        dut->clk = !dut->clk;
        dut->eval();
        main_time++;
    }
    dut->reset_n = 1;

    // Test patterns as 4 uint64_t values
    const std::vector<std::vector<uint64_t>> test_patterns = {
        {0xAAAAAAAAAAAAAAAA, 0xBBBBBBBBBBBBBBBB, 0xCCCCCCCCCCCCCCCC, 0xDDDDDDDDDDDDDDDD},
        {0x1111111111111111, 0x2222222222222222, 0x3333333333333333, 0x4444444444444444},
        {0x5555555555555555, 0x6666666666666666, 0x7777777777777777, 0x8888888888888888},
        {0x9999999999999999, 0xAAAAAAAAAAAAAAAA, 0xBBBBBBBBBBBBBBBB, 0xCCCCCCCCCCCCCCCC}
    };

    // Helper function to set 256-bit write_data from 4 uint64_t values
    auto set_write_data = [&](const std::vector<uint64_t>& pattern) {
        for (int i = 0; i < 4; i++) {
            // Set lower 32 bits
            dut->write_data[i*2]   = static_cast<uint32_t>(pattern[i] & 0xFFFFFFFF);
            // Set upper 32 bits
            dut->write_data[i*2+1] = static_cast<uint32_t>((pattern[i] >> 32) & 0xFFFFFFFF);
        }
    };

    // Updated: Read data from unpacked array (32 bytes, each 8 bits)
    auto read_data_to_hex = [&]() -> std::string {
        std::ostringstream oss;
        oss << std::hex << std::setfill('0');
        // Combine bytes to form 32-bit words for comparison
        for (int word = 0; word < WORDS_PER_TILE; word++) {
            uint32_t combined_word = 0;
            for (int byte_in_word = 0; byte_in_word < 4; byte_in_word++) {
                int byte_index = word * 4 + byte_in_word;
                combined_word |= (static_cast<uint32_t>(dut->read_data[byte_index]) << (byte_in_word * 8));
            }
            oss << std::setw(8) << combined_word;
        }
        return oss.str();
    };

    // Helper to get expected hex string
    auto pattern_to_hex = [](const std::vector<uint64_t>& pattern) -> std::string {
        std::ostringstream oss;
        oss << std::hex << std::setfill('0');
        for (const auto& val : pattern) {
            // Print each 64-bit value as 16 hex characters
            oss << std::setw(16) << val;
        }
        return oss.str();
    };

    // Write test patterns to buffer 0
    std::cout << "\n=== Writing to Buffer 0 ===" << std::endl;
    dut->write_enable = 1;
    dut->write_buffer = 0;
    
    for(int tile = 0; tile < TILE_COUNT; tile++) {
        const int pattern_idx = tile % test_patterns.size();
        set_write_data(test_patterns[pattern_idx]);
        
        // Clock strobe
        dut->clk = 0;
        dut->eval();
        main_time++;
        
        dut->clk = 1;
        dut->eval();
        main_time++;
        
        std::cout << "Wrote tile " << tile << ": 0x" 
                  << pattern_to_hex(test_patterns[pattern_idx]) << std::endl;
        
        // Check writing_done on last tile
        if(tile == TILE_COUNT - 1) {
            if(dut->writing_done != 1) {
                std::cerr << "Error: writing_done not asserted!" << std::endl;
                exit(EXIT_FAILURE);
            }
            std::cout << "writing_done asserted" << std::endl;
        }
    }

    // Write different patterns to buffer 1
    std::cout << "\n=== Writing to Buffer 1 ===" << std::endl;
    dut->write_buffer = 1;
    
    for(int tile = 0; tile < TILE_COUNT; tile++) {
        const int pattern_idx = (TILE_COUNT - 1 - tile) % test_patterns.size();
        set_write_data(test_patterns[pattern_idx]);
        
        // Clock strobe
        dut->clk = 0;
        dut->eval();
        main_time++;
        
        dut->clk = 1;
        dut->eval();
        main_time++;
        
        std::cout << "Wrote tile " << tile << ": 0x" 
                  << pattern_to_hex(test_patterns[pattern_idx]) << std::endl;
    }
    dut->write_enable = 0;

    // Read from buffer 0
    std::cout << "\n=== Reading from Buffer 0 ===" << std::endl;
    dut->read_enable = 1;
    dut->read_buffer = 0;
    
    for(int tile = 0; tile < TILE_COUNT; tile++) {
        // Clock strobe (read happens on rising edge)
        dut->clk = 0;
        dut->eval();
        main_time++;
        
        dut->clk = 1;
        dut->eval();
        main_time++;
        
        const int pattern_idx = tile % test_patterns.size();
        const std::string read_hex = read_data_to_hex();
        const std::string expected_hex = pattern_to_hex(test_patterns[pattern_idx]);
        
        std::cout << "Read tile " << tile << ": 0x" << read_hex << std::endl;
        std::cout << "Expected   : 0x" << expected_hex << std::endl;
        
        // Verify data
        if(read_hex != expected_hex) {
            std::cerr << "Mismatch! Expected: 0x" << expected_hex 
                      << " Got: 0x" << read_hex << std::endl;
            exit(EXIT_FAILURE);
        }
        
        // Check reading_done on last tile
        if(tile == TILE_COUNT - 1) {
            if(dut->reading_done != 1) {
                std::cerr << "Error: reading_done not asserted!" << std::endl;
                exit(EXIT_FAILURE);
            }
            std::cout << "reading_done asserted" << std::endl;
        }
    }

    // Read from buffer 1
    std::cout << "\n=== Reading from Buffer 1 ===" << std::endl;
    dut->read_buffer = 1;
    
    for(int tile = 0; tile < TILE_COUNT; tile++) {
        // Clock strobe
        dut->clk = 0;
        dut->eval();
        main_time++;
        
        dut->clk = 1;
        dut->eval();
        main_time++;
        
        const int pattern_idx = (TILE_COUNT - 1 - tile) % test_patterns.size();
        const std::string read_hex = read_data_to_hex();
        const std::string expected_hex = pattern_to_hex(test_patterns[pattern_idx]);
        
        std::cout << "Read tile " << tile << ": 0x" << read_hex << std::endl;
        std::cout << "Expected   : 0x" << expected_hex << std::endl;
        
        // Verify data
        if(read_hex != expected_hex) {
            std::cerr << "Mismatch! Expected: 0x" << expected_hex 
                      << " Got: 0x" << read_hex << std::endl;
            exit(EXIT_FAILURE);
        }
    }
    dut->read_enable = 0;

    // Test reset functionality
    std::cout << "\n=== Testing Reset ===" << std::endl;
    dut->reset_n = 0;
    dut->clk = 0;
    dut->eval();
    main_time++;
    
    dut->clk = 1;
    dut->eval();
    main_time++;
    
    // Should reset to all zeros - check unpacked array
    bool all_zero = true;
    for (int i = 0; i < TILE_SIZE; i++) {
        if (dut->read_data[i] != 0) {
            all_zero = false;
            break;
        }
    }
    if(!all_zero) {
        std::cerr << "Reset failed! Non-zero read_data: 0x" 
                  << read_data_to_hex() << std::endl;
        exit(EXIT_FAILURE);
    }
    std::cout << "Reset successful" << std::endl;

    // Cleanup
    dut->final();
    delete dut;

    std::cout << "\nAll tests passed successfully!" << std::endl;
    return EXIT_SUCCESS;
}