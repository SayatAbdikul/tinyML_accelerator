// System-Level Architecture
// Use: dot -Tpng system_architecture.dot -o system_architecture.png

digraph TinyML_System {
    rankdir=TB;
    node [shape=box, style="rounded,filled", fillcolor=lightblue];
    
    // Define nodes
    subgraph cluster_top {
        label="tinyml_accelerator_top";
        style=filled;
        fillcolor=lightgray;
        
        start [label="START\n(1 cycle pulse)", shape=circle, fillcolor=lightgreen];
        done [label="DONE\n(1 cycle pulse)", shape=circle, fillcolor=orange];
        
        fetch [label="Fetch Unit\n(fetch_unit)", fillcolor=lightyellow];
        decoder [label="Instruction Decoder\n(i_decoder)", fillcolor=lightyellow];
        execution [label="Modular Execution Unit\n(modular_execution_unit)", fillcolor=lightpink];
        
        subgraph cluster_memory {
            label="Memory System (4 instances)";
            style=filled;
            fillcolor=white;
            
            mem_fetch [label="Instruction\nMemory", shape=cylinder];
            mem_loadv [label="Load_V\nMemory", shape=cylinder];
            mem_loadm [label="Load_M\nMemory", shape=cylinder];
            mem_store [label="Store\nMemory", shape=cylinder];
        }
        
        output [label="Output\ny[0:9]", shape=ellipse, fillcolor=lightgreen];
    }
    
    // Control flow
    start -> fetch [label="start=1"];
    fetch -> decoder [label="instruction[63:0]"];
    decoder -> execution [label="decoded\nfields"];
    execution -> done [label="exec_done"];
    execution -> output [label="result[]"];
    
    // Memory connections
    fetch -> mem_fetch [label="read", style=dashed];
    execution -> mem_loadv [label="read", style=dashed];
    execution -> mem_loadm [label="read", style=dashed];
    execution -> mem_store [label="write", style=dashed];
    
    // FSM states
    fsm [label="FSM States:\nIDLE → FETCH → WAIT_FETCH →\nDECODE → EXECUTE_START →\nEXECUTE_WAIT → DONE", 
         shape=note, fillcolor=lightyellow];
}
