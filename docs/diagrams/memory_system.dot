// Memory System Architecture
// Use: dot -Tpng memory_system.dot -o memory_system.png

digraph Memory_System {
    rankdir=LR;
    node [shape=box, style="rounded,filled"];
    
    // DRAM hex file
    dram_hex [label="dram.hex\n(Initial Memory Image)", 
              shape=note, fillcolor=lightyellow];
    
    // Memory instances
    subgraph cluster_memories {
        label="4 Separate Memory Instances";
        style=filled;
        fillcolor=lightgray;
        
        mem1 [label="Instruction Memory\n(fetch_unit)\n0x000000-0x000700\n(1792 bytes)", 
              shape=cylinder, fillcolor=lightblue];
        mem2 [label="Load_V Memory\n(load_v)\n0x000700-0x010700\n(64 KB)", 
              shape=cylinder, fillcolor=lightgreen];
        mem3 [label="Load_M Memory\n(load_m)\n0x010700-0x020000\n(~62 KB)", 
              shape=cylinder, fillcolor=lightpink];
        mem4 [label="Store Memory\n(store)\n0x020000-0x030000\n(64 KB)", 
              shape=cylinder, fillcolor=lightyellow];
    }
    
    // Initialization
    dram_hex -> mem1 [label="$readmemh\n(at time 0)", style=dashed];
    dram_hex -> mem2 [label="$readmemh\n(at time 0)", style=dashed];
    dram_hex -> mem3 [label="$readmemh\n(at time 0)", style=dashed];
    dram_hex -> mem4 [label="$readmemh\n(at time 0)", style=dashed];
    
    // Memory map details
    subgraph cluster_map {
        label="Memory Map";
        style=filled;
        fillcolor=white;
        rank=same;
        
        region1 [label="0x000000-0x000700\nInstructions\n(1792 bytes)", 
                 shape=note, fillcolor=lightblue];
        region2 [label="0x000700-0x010700\nInput Vectors\n(64 KB)", 
                 shape=note, fillcolor=lightgreen];
        region3 [label="0x010700-0x013000\nWeight Matrices\n(11 KB)", 
                 shape=note, fillcolor=lightpink];
        region4 [label="0x013000-0x020000\nBias Vectors\n(52 KB)", 
                 shape=note, fillcolor=lightpink];
        region5 [label="0x020000-0x030000\nOutput Buffers\n(64 KB)", 
                 shape=note, fillcolor=lightyellow];
    }
    
    // Access patterns
    fetch_access [label="Fetch Unit\nReads instructions\nSequentially", 
                  shape=component, fillcolor=lightcyan];
    load_access [label="Load Units\nRead data\nTile-based", 
                 shape=component, fillcolor=lightcyan];
    store_access [label="Store Unit\nWrites results\nTile-based", 
                  shape=component, fillcolor=lightcyan];
    
    fetch_access -> mem1;
    load_access -> mem2;
    load_access -> mem3;
    store_access -> mem4;
    
    // Synchronization note
    sync_note [label="⚠️ CRITICAL:\n\nMemories are SEPARATE!\nNo hardware interconnect!\n\nTestbench must manually\nsynchronize all 4 instances\nwhen updating memory\nduring simulation.", 
               shape=note, fillcolor=orange];
    
    mem1 -> sync_note [style=invis];
}
