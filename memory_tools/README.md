# Memory Tools

This directory contains C++ utilities for interacting with the FPGA accelerator's memory via UART. These tools allow you to load programs, inspect memory contents, and read back inference results.

## Tools Overview

### 1. `uart_load_hex`
**Purpose**: Loads a hex file (generated by the compiler) into the FPGA memory.
**Features**:
-  Loads binary data from a text-based hex file (one byte per line).
-  Chunked transfer with flow control (tcdrain) for reliability.
-  **Verification**: Reads back sampled addresses to ensure data integrity.
-  **Progress Bar**: Visual feedback during upload.

**Usage**:
```bash
./uart_load_hex <port> <hex_file> [--limit N]
```
**Example**:
```bash
./uart_load_hex /dev/tty.usbserial-1 ../../compiler/dram_42.hex
```

### 2. `uart_memory`
**Purpose**: A versatile tool for low-level memory interaction.
**Commands**:
- `load <file>`: Load a raw binary file (requires S2 pressed).
- `read <addr> <len>`: Read bytes from a specific address.
- `dump <addr> <len>`: Hex dump of a memory region.
- `probe`: Test UART connectivity (reads 1 byte from 0x0000).
- `listen [secs]`: Passive listener for incoming bytes.
- `test`: Self-test (write pattern, read back, verify).
- `echo`: Test UART loopback (send 0xBB, expect 0xCC).

**Usage**:
```bash
./uart_memory <port> <command> [args...]
```
**Examples**:
```bash
./uart_memory /dev/tty.usbserial-1 probe
./uart_memory /dev/tty.usbserial-1 dump 0x0000 64
./uart_memory /dev/tty.usbserial-1 read 0x08C0 10
```

### 3. `uart_read_max`
**Purpose**: Reads the inference results from the accelerator and determines the predicted class.
**Functionality**:
- Reads 10 bytes from the hardcoded Output Buffer address (`0x08C0`).
- Prints all 10 values.
- Identifies and prints the index of the maximum value (the prediction).

**Usage**:
```bash
./uart_read_max <port>
```

---

## Compilation

A `Makefile` is provided to compile all tools.

**Build all tools**:
```bash
make
```

**Clean**:
```bash
make clean
```

**Manual Compilation** (if needed):
```bash
g++ -std=c++17 -o uart_load_hex uart_load_hex.cpp
g++ -std=c++17 -o uart_memory uart_memory.cpp
g++ -std=c++17 -o uart_read_max uart_read_max.cpp
```

## Typical Workflow

1.  **Generate Hex File**: Use the compiler to create a DRAM image for a test input.
    ```bash
    cd ../../compiler
    python generate_dram_for_input.py --input-index 7 --output dram_7.hex
    ```

2.  **Load to FPGA**:
    *   **Press S2** on the FPGA (Enter Load Mode).
    *   Run loader:
        ```bash
        ./uart_load_hex /dev/tty.usbserial-1 ../../compiler/dram_7.hex
        ```
    *   **Release S2** (Enter Normal Mode) when prompted.

3.  **Run Inference**:
    *   **Press S1** (Reset) to start the accelerator.
    *   Wait for invalidation LED (LED5) to turn off (inference complete).

4.  **Read Result**:
    ```bash
    ./uart_read_max /dev/tty.usbserial-1
    ```
    Output should match the label (e.g., "7").
